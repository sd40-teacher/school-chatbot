<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>VRM Avatar Viewer</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            overflow: hidden;
        }
        
        #vrm-container {
            width: 100%;
            height: 100vh;
            position: relative;
        }
        
        #vrm-canvas {
            width: 100%;
            height: 100%;
            display: block;
        }
        
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 18px;
            text-align: center;
            z-index: 100;
        }
        
        .spinner {
            border: 4px solid rgba(255,255,255,0.3);
            border-top: 4px solid white;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 0 auto 15px;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        #controls {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 10px;
            z-index: 10;
        }
        
        .control-btn {
            padding: 10px 20px;
            border: none;
            border-radius: 25px;
            background: rgba(255,255,255,0.9);
            color: #333;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
        }
        
        .control-btn:hover {
            background: white;
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0,0,0,0.3);
        }
        
        .control-btn.active {
            background: #667eea;
            color: white;
        }
        
        #speech-indicator {
            position: absolute;
            top: 20px;
            right: 20px;
            padding: 10px 20px;
            background: rgba(0,0,0,0.5);
            color: white;
            border-radius: 20px;
            display: none;
            z-index: 10;
        }
        
        #speech-indicator.speaking {
            display: block;
            animation: pulse 1s infinite;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
    </style>
</head>
<body>
    <div id="vrm-container">
        <canvas id="vrm-canvas"></canvas>
        
        <div id="loading">
            <div class="spinner"></div>
            <div>ì•„ë°”íƒ€ë¥¼ ë¶ˆëŸ¬ì˜¤ëŠ” ì¤‘...</div>
        </div>
        
        <div id="speech-indicator">ğŸ™ï¸ ë§í•˜ëŠ” ì¤‘...</div>
        
        <div id="controls">
            <button class="control-btn" onclick="playAnimation('idle')">ğŸ˜Š ê¸°ë³¸</button>
            <button class="control-btn" onclick="playAnimation('happy')">ğŸ˜„ ê¸°ì¨</button>
            <button class="control-btn" onclick="playAnimation('thinking')">ğŸ¤” ìƒê°</button>
            <button class="control-btn" onclick="playAnimation('surprised')">ğŸ˜® ë†€ëŒ</button>
            <button class="control-btn" onclick="playAnimation('wave')">ğŸ‘‹ ì¸ì‚¬</button>
        </div>
    </div>

    <!-- Three.js ë° VRM ë¼ì´ë¸ŒëŸ¬ë¦¬ -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.158.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@pixiv/three-vrm@3.1.3/lib/three-vrm.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.158.0/examples/js/loaders/GLTFLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.158.0/examples/js/controls/OrbitControls.js"></script>

    <script>
        // ì „ì—­ ë³€ìˆ˜
        let scene, camera, renderer, controls;
        let currentVrm = null;
        let clock = new THREE.Clock();
        let mixer = null;
        
        // ë¦½ì‹±í¬ ê´€ë ¨
        let isSpeaking = false;
        let lipSyncInterval = null;
        
        // ê¸°ë³¸ VRM ëª¨ë¸ URL (ìƒ˜í”Œ)
        const DEFAULT_VRM_URL = 'https://pixiv.github.io/three-vrm/packages/three-vrm/examples/models/VRM1_Constraint_Twist_Sample.vrm';
        
        // ì´ˆê¸°í™”
        function init() {
            const container = document.getElementById('vrm-container');
            const canvas = document.getElementById('vrm-canvas');
            
            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x667eea);
            
            // Camera
            camera = new THREE.PerspectiveCamera(
                35,
                container.clientWidth / container.clientHeight,
                0.1,
                1000
            );
            camera.position.set(0, 1.4, 2);
            
            // Renderer
            renderer = new THREE.WebGLRenderer({ 
                canvas: canvas,
                antialias: true,
                alpha: true
            });
            renderer.setSize(container.clientWidth, container.clientHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.outputEncoding = THREE.sRGBEncoding;
            
            // Controls
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.target.set(0, 1.0, 0);
            controls.enablePan = false;
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.minDistance = 1;
            controls.maxDistance = 5;
            controls.update();
            
            // Lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(1, 2, 1);
            scene.add(directionalLight);
            
            const backLight = new THREE.DirectionalLight(0xffffff, 0.3);
            backLight.position.set(-1, 1, -1);
            scene.add(backLight);
            
            // ë°”ë‹¥ ê·¸ë¦¬ë“œ
            const gridHelper = new THREE.GridHelper(10, 10, 0xffffff, 0xcccccc);
            gridHelper.material.opacity = 0.2;
            gridHelper.material.transparent = true;
            scene.add(gridHelper);
            
            // VRM ë¡œë“œ
            loadVRM(DEFAULT_VRM_URL);
            
            // ë¦¬ì‚¬ì´ì¦ˆ í•¸ë“¤ëŸ¬
            window.addEventListener('resize', onWindowResize);
            
            // ì• ë‹ˆë©”ì´ì…˜ ë£¨í”„ ì‹œì‘
            animate();
        }
        
        // VRM ë¡œë“œ
        function loadVRM(url) {
            const loader = new THREE.GLTFLoader();
            
            loader.load(
                url,
                async (gltf) => {
                    try {
                        const vrm = await THREE.VRM.from(gltf);
                        
                        // ê¸°ì¡´ VRM ì œê±°
                        if (currentVrm) {
                            scene.remove(currentVrm.scene);
                            THREE.VRM.dispose(currentVrm);
                        }
                        
                        currentVrm = vrm;
                        scene.add(vrm.scene);
                        
                        // ì´ˆê¸° íšŒì „ (ì •ë©´ ë³´ê¸°)
                        vrm.scene.rotation.y = Math.PI;
                        
                        // ì¹´ë©”ë¼ íƒ€ê²Ÿ ì¡°ì •
                        const head = vrm.humanoid?.getNormalizedBoneNode('head');
                        if (head) {
                            const headPos = new THREE.Vector3();
                            head.getWorldPosition(headPos);
                            controls.target.copy(headPos);
                            controls.target.y -= 0.1;
                        }
                        
                        // ë¡œë”© ì™„ë£Œ
                        document.getElementById('loading').style.display = 'none';
                        
                        // Idle í‘œì • ì„¤ì •
                        setExpression('neutral', 1.0);
                        
                        console.log('VRM ë¡œë“œ ì™„ë£Œ!');
                    } catch (error) {
                        console.error('VRM íŒŒì‹± ì˜¤ë¥˜:', error);
                        document.getElementById('loading').innerHTML = 
                            '<div style="color: #ff6b6b;">âš ï¸ ëª¨ë¸ ë¡œë“œ ì‹¤íŒ¨</div>';
                    }
                },
                (progress) => {
                    const percent = (progress.loaded / progress.total * 100).toFixed(0);
                    document.getElementById('loading').innerHTML = 
                        `<div class="spinner"></div><div>ë¡œë”© ì¤‘... ${percent}%</div>`;
                },
                (error) => {
                    console.error('VRM ë¡œë“œ ì˜¤ë¥˜:', error);
                    document.getElementById('loading').innerHTML = 
                        '<div style="color: #ff6b6b;">âš ï¸ ëª¨ë¸ì„ ë¶ˆëŸ¬ì˜¬ ìˆ˜ ì—†ìŠµë‹ˆë‹¤</div>';
                }
            );
        }
        
        // í‘œì • ì„¤ì •
        function setExpression(name, value) {
            if (!currentVrm || !currentVrm.expressionManager) return;
            
            // ëª¨ë“  í‘œì • ì´ˆê¸°í™”
            const expressions = currentVrm.expressionManager;
            if (expressions.setValue) {
                expressions.setValue('happy', 0);
                expressions.setValue('angry', 0);
                expressions.setValue('sad', 0);
                expressions.setValue('surprised', 0);
                expressions.setValue('relaxed', 0);
                
                // ìƒˆ í‘œì • ì„¤ì •
                if (name !== 'neutral') {
                    expressions.setValue(name, value);
                }
            }
        }
        
        // ì• ë‹ˆë©”ì´ì…˜ ì¬ìƒ
        function playAnimation(type) {
            if (!currentVrm) return;
            
            // ë²„íŠ¼ í™œì„±í™” í‘œì‹œ
            document.querySelectorAll('.control-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            event.target.classList.add('active');
            
            switch(type) {
                case 'idle':
                    setExpression('neutral', 1.0);
                    break;
                case 'happy':
                    setExpression('happy', 1.0);
                    break;
                case 'thinking':
                    setExpression('relaxed', 0.5);
                    // ê³ ê°œ ì‚´ì§ ê¸°ìš¸ì´ê¸°
                    if (currentVrm.humanoid) {
                        const head = currentVrm.humanoid.getNormalizedBoneNode('head');
                        if (head) {
                            head.rotation.z = 0.1;
                            setTimeout(() => { head.rotation.z = 0; }, 2000);
                        }
                    }
                    break;
                case 'surprised':
                    setExpression('surprised', 1.0);
                    break;
                case 'wave':
                    animateWave();
                    break;
            }
        }
        
        // ì¸ì‚¬ ì• ë‹ˆë©”ì´ì…˜
        function animateWave() {
            if (!currentVrm || !currentVrm.humanoid) return;
            
            const rightUpperArm = currentVrm.humanoid.getNormalizedBoneNode('rightUpperArm');
            const rightLowerArm = currentVrm.humanoid.getNormalizedBoneNode('rightLowerArm');
            
            if (rightUpperArm && rightLowerArm) {
                // íŒ” ë“¤ê¸°
                let angle = 0;
                const waveAnimation = setInterval(() => {
                    angle += 0.1;
                    rightUpperArm.rotation.z = -1.2 + Math.sin(angle * 3) * 0.2;
                    rightLowerArm.rotation.y = -0.5 + Math.sin(angle * 5) * 0.3;
                    
                    if (angle > Math.PI * 2) {
                        clearInterval(waveAnimation);
                        // ì›ë˜ ìœ„ì¹˜ë¡œ
                        rightUpperArm.rotation.z = 0;
                        rightLowerArm.rotation.y = 0;
                    }
                }, 16);
            }
        }
        
        // ë¦½ì‹±í¬ ì‹œì‘
        function startLipSync() {
            if (!currentVrm || !currentVrm.expressionManager) return;
            
            isSpeaking = true;
            document.getElementById('speech-indicator').classList.add('speaking');
            
            const expressions = currentVrm.expressionManager;
            let time = 0;
            
            lipSyncInterval = setInterval(() => {
                time += 0.1;
                // ê°„ë‹¨í•œ ì… ì›€ì§ì„ ì‹œë®¬ë ˆì´ì…˜
                const mouthValue = (Math.sin(time * 10) + 1) * 0.3;
                if (expressions.setValue) {
                    expressions.setValue('aa', mouthValue);
                    expressions.setValue('oh', mouthValue * 0.5);
                }
            }, 50);
        }
        
        // ë¦½ì‹±í¬ ì¢…ë£Œ
        function stopLipSync() {
            isSpeaking = false;
            document.getElementById('speech-indicator').classList.remove('speaking');
            
            if (lipSyncInterval) {
                clearInterval(lipSyncInterval);
                lipSyncInterval = null;
            }
            
            if (currentVrm && currentVrm.expressionManager) {
                const expressions = currentVrm.expressionManager;
                if (expressions.setValue) {
                    expressions.setValue('aa', 0);
                    expressions.setValue('oh', 0);
                }
            }
        }
        
        // ì™¸ë¶€ì—ì„œ í˜¸ì¶œ ê°€ëŠ¥í•œ í•¨ìˆ˜ë“¤
        window.vrmController = {
            loadModel: loadVRM,
            setExpression: setExpression,
            playAnimation: playAnimation,
            startLipSync: startLipSync,
            stopLipSync: stopLipSync,
            speak: function(duration) {
                startLipSync();
                setTimeout(stopLipSync, duration);
            }
        };
        
        // ìœˆë„ìš° ë¦¬ì‚¬ì´ì¦ˆ
        function onWindowResize() {
            const container = document.getElementById('vrm-container');
            camera.aspect = container.clientWidth / container.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(container.clientWidth, container.clientHeight);
        }
        
        // ì• ë‹ˆë©”ì´ì…˜ ë£¨í”„
        function animate() {
            requestAnimationFrame(animate);
            
            const delta = clock.getDelta();
            
            if (currentVrm) {
                currentVrm.update(delta);
            }
            
            if (mixer) {
                mixer.update(delta);
            }
            
            controls.update();
            renderer.render(scene, camera);
        }
        
        // ì™¸ë¶€ ë©”ì‹œì§€ ìˆ˜ì‹  (Streamlitê³¼ í†µì‹ )
        window.addEventListener('message', (event) => {
            const data = event.data;
            if (data.type === 'loadVRM') {
                loadVRM(data.url);
            } else if (data.type === 'speak') {
                window.vrmController.speak(data.duration || 3000);
            } else if (data.type === 'expression') {
                setExpression(data.name, data.value || 1.0);
            }
        });
        
        // ì´ˆê¸°í™” ì‹¤í–‰
        init();
    </script>
</body>
</html>
